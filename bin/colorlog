#!/usr/bin/env ruby

require 'optparse'
require 'rainbow'
require 'yaml'

COLORS = [
    :black,
    :red,
    :green,
    :yellow,
    :blue,
    :magenta,
    :cyan,
    :white,
    :default
]

options = {
    default: {
        color: :default,
        regex: //
    },
    success: {
        color: :green,
        regex: /success/i
    },
    warning: {
        color: :yellow,
        regex: /warning/i
    },
    error: {
        color: :red,
        regex: /^(?:(?!\bTests\b).)*(?:failure|error).*$/i
    },
    custom1: {
        color: :blue,
        regex: /custom1/
    }
}

CONFIG_FILE = File.join(ENV['HOME'], '.colorlog.rc.yaml')
if File.exists? CONFIG_FILE
  config_options = YAML.load_file(CONFIG_FILE)
  options.merge!(config_options)
else
  File.open(CONFIG_FILE, 'w') { |file| YAML::dump(options, file) }
  STDERR.puts "Initialized configuration file in #{CONFIG_FILE}"
end

option_parser = OptionParser.new do |opts|
  executable_name = File.basename($PROGRAM_NAME)
  opts.banner = "Read a file and color the lines in " +
      "different color depending on the content of the line matching different Regexp.

Usage: #{executable_name} [options] filename

"

  opts.on('--success-color COLOR', COLORS, 'color to use when success matches ' + COLORS.map { |color| color.id2name }.to_s) do |success_color|
    options[:success][:color] = success_color
  end

  opts.on('--warning-color COLOR', COLORS, 'color to use when warning matches ' + COLORS.map { |color| color.id2name }.to_s) do |warning_color|
    options[:warning][:color] = warning_color
  end

  opts.on('--error-color COLOR', COLORS, 'color to use when error matches ' + COLORS.map { |color| color.id2name }.to_s) do |error_color|
    options[:error][:color] = error_color
  end

  opts.on('--default-color COLOR', COLORS, 'color to use when no match is found ' + COLORS.map { |color| color.id2name }.to_s) do |default_color|
    options[:default][:color] = default_color
  end

  opts.on('-cc1','--custom-color1 COLOR', COLORS, 'color to use when custom1 match is found ' + COLORS.map { |color| color.id2name }.to_s) do |custom_color1|
    options[:custom1][:color] = custom_color1
  end

  opts.on('-s', '--success REGEXP', Regexp, 'RegExp that matched will turn the line green  (default ' + options[:success].inspect + ')') do |success|
    options[:success][:regex] = success
  end

  opts.on('-w', '--warning REGEXP', Regexp, 'RegExp that matched will turn the line yellow (default ' + options[:warning].inspect + ')') do |warning|
    options[:warning][:regex] = warning
  end

  opts.on('-e', '--error REGEXP', Regexp, 'RegExp that matched will turn the line red    (default ' + options[:error].inspect + ')') do |error|
    options[:error][:regex] = error
  end

  opts.on('-c1', '--custom1 REGEXP', Regexp, 'RegExp that matched will turn the line in --custom-color1  (default ' + options[:custom1].inspect + ')') do |custom1|
    options[:custom1] = custom1
  end

end

option_parser.parse!

def color_print(line, options)
  actual_color = options[:default][:color]

  options.each do |key, value|
    regexp = Regexp.new(value[:regex])
    color = value[:color]
    if line =~ regexp
      actual_color = color
    end
  end

  printf("%s".foreground(actual_color), line)

end

filename = ARGV.shift

if filename.nil?
  if STDIN.tty?
    puts "You should provide a file"
    exit 1
  end

  ARGF.each do |line|
    color_print(line, options)
  end
else
  File.open(File.expand_path(filename), 'r') do |file|
    file.readlines.each do |line|
      color_print(line, options)
    end
  end
end
